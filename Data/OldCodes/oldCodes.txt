    def getScoreList(self, list ):
        returnList = []
        for curBinCount in range(self.maxFeatureCount-2, self.minFeatureCount-1, -1):
            curBinIndex = curBinCount - self.minFeatureCount
            lookUpList = list[-curBinCount:]
            score = 0.0
            curKey = keyMaker(lookUpList)
            if curKey in self.scoreMap:
                score = self.scoreMap[curKey]
                returnList.append(score)
                self.notMissCount += 1
                continue
            self.missCount += 1
            if lookUpList[-1] < 0.0:
                score = self.__getScoreForButtomElement(lookUpList, self.inputs[curBinIndex+1].getSorter(), curBinIndex + 1)
            elif lookUpList[-1] > 0.0:
                score = self.__getScoreForRisingElement(lookUpList, self.inputs[curBinIndex].getSorter(), curBinIndex + 1)
            self.scoreMap[curKey] = score

            returnList.append(score)

        return returnList

    def setScore( self, transIndex, peakIndex, score ):
        self.transactionHelperList[transIndex].peakHelperList[peakIndex].score = score


    def getScore(self, list ):
        for curBinCount in range(self.maxFeatureCount-2, self.minFeatureCount-1, -1):
            curBinIndex = curBinCount - self.minFeatureCount
            lookUpList = list[-curBinCount:]

            score = 0.0
            curKey = keyMaker(lookUpList)
            if curKey in self.scoreMap:
                score = self.scoreMap[curKey]
            else:
                if lookUpList[-1] < 0.0:
                    score = self.__getScoreForButtomElement(lookUpList, self.inputs[curBinIndex+1].getSorter(), curBinIndex + 1)
                elif lookUpList[-1] > 0.0:
                    score = self.__getScoreForRisingElement(lookUpList, self.inputs[curBinIndex].getSorter(), curBinIndex + 1)
                self.scoreMap[curKey] = score

            if abs(score) > 6.0:
                return score
        return 0.0


#    for peakHelper in transHelper.peakHelperList:
#        scoreList = self.getScoreList(peakHelper.inputRise)
#        peakHelper.scoreList = scoreList
#   print("Finalizing index", counter, " Not missed " , self.notMissCount, " missed ", self.missCount)



    def __getFactor(self, val, curIndex ):
        ngramFactor = lambda x :  0.8 + 0.15*x + 0.05*x*x
        if val < 4.0:
            return 0.5 * ngramFactor(curIndex)
        elif val < 5.0:
            return 0.6 * ngramFactor(curIndex)
        elif val < 7.5:
            return 0.8 * ngramFactor(curIndex)
        elif val < 10.0:
            return 1.0 * ngramFactor(curIndex)
        elif val < 15.0:
            return 1.5 * ngramFactor(curIndex)
        elif val < 20.0:
            return 2.0 * ngramFactor(curIndex)
        elif val < 30.0:
            return 3.0 * ngramFactor(curIndex)
        else:
            return 5.0 * ngramFactor(curIndex)

    def __getScoreForButtomElement(self, oneSampleNBin, nPlusOneCompleteInputSorter, curIndex):
        score = 0.0
        firstElem = oneSampleNBin[0]
        factor = self.__getFactor(abs(firstElem), curIndex)
        startIndex = nPlusOneCompleteInputSorter.getIndex( firstElem - factor)
        endIndex = nPlusOneCompleteInputSorter.getIndex( firstElem + factor)
        #print(firstElem, " ",curIndex , " ", startIndex, " ", endIndex, " ",  len(nPlusOneCompleteInputSorter.sortedPriceList), )
        for index in  range(startIndex, endIndex):
            elemList = nPlusOneCompleteInputSorter.sortedPriceList[index]
            score += self.__getScoreForButtom(oneSampleNBin, elemList, curIndex)
        return score

    def __getScoreForRisingElement(self, oneSampleNBin, nBinCompleteInputSorter, curIndex):
        score = 0
        firstElem = oneSampleNBin[0]
        factor = self.__getFactor(abs(firstElem), curIndex)
        startIndex = nBinCompleteInputSorter.getIndex( firstElem - factor)
        endIndex = nBinCompleteInputSorter.getIndex( firstElem + factor)

        for index in  range(startIndex, endIndex):
            elemList = nBinCompleteInputSorter.sortedPriceList[index]
            score += self.__getScoreForRising(oneSampleNBin, elemList, curIndex)
        return score


    def __checkPositivitySingleVal(self, lhs, rhs, curIndex):
        ngramFactor = lambda x :  0.8 + 0.15*x + 0.05*x*x
        if lhs * rhs < 0:
            return False
        diff = abs(lhs - rhs)
        lshAbs = abs(lhs)
        if lshAbs < 4.0:
            return diff < 0.5 * ngramFactor(curIndex)
        elif lshAbs < 5.0:
            return diff < 0.6 * ngramFactor(curIndex)
        elif lshAbs < 7.5:
            return diff < 0.8 * ngramFactor(curIndex)
        elif lshAbs < 10.0:
            return diff < 1.0 * ngramFactor(curIndex)
        elif lshAbs < 15.0:
            return diff < 1.5 * ngramFactor(curIndex)
        elif lshAbs < 20.0:
            return diff < 2.0 * ngramFactor(curIndex)
        elif lshAbs < 30.0:
            return diff < 3.0 * ngramFactor(curIndex)
        else:
            return diff < 5.0 * ngramFactor(curIndex)

    def __getScoreForRising(self, oneSampleNBin, oneSampleOtherBin, curIndex):

        if not self.__checkPositivitySingleVal(oneSampleNBin[0],oneSampleOtherBin[0], curIndex):
            return False
        isAllValid = all(
            [self.__checkPositivitySingleVal(x, y, curIndex) for x, y in zip(oneSampleNBin[:-1], oneSampleOtherBin[:-1])])
        if not isAllValid:
            return 0.0
        diff = oneSampleOtherBin[-1] - oneSampleNBin[-1]
        if diff < -1.5:
            return 0.0

        return self.__clampVal( diff - 4.0 )

    def __getScoreForButtom(self, oneSampleNBin, oneSampleNPluseOneBin, curIndex):
        if not self.__checkPositivitySingleVal(oneSampleNBin[0],oneSampleNPluseOneBin[0], curIndex):
            return False
        isAllValid = all([self.__checkPositivitySingleVal(x, y, curIndex) for x, y in zip(oneSampleNBin[:-1], oneSampleNPluseOneBin[:-2])])
        if not isAllValid:
            return 0.0
        diff = oneSampleNBin[-1] - oneSampleNPluseOneBin[-2]
        if diff < -1.5:
            return 0.0
        elif diff < 1.5:
            return self.__clampVal(oneSampleNPluseOneBin[-1] - abs(diff))#Positive effect
        else:
            return -self.__clampVal(diff)#Negative effect

    def __clampVal(self, val ):
        return min(5.0, max(val, -5.0))



    def keyMaker(list):
        key = 0
        for index in range(len(list)):
            key += int(min(999, int(abs(list[index]) * 10))* pow(1000, index))
        if list[0] < 0.0:
          key *= -1
        return key


scikit.py:

extraFolderPath = os.path.abspath(os.getcwd()) + "/Data/ExtraData/"

folderPath = os.path.abspath(os.getcwd()) + "/Data/CompleteData/"
def compareInt(x,y):
    return int(x.split("_")[1]) - int(y.split("_")[1])

onlyfiles = [f for f in listdir(folderPath) if isfile(join(folderPath, f))]
onlyfiles = list(sorted( onlyfiles, key=functools.cmp_to_key(compareInt) ))
onlyfiles = list(map( lambda x:  folderPath+x, onlyfiles))
trainingReshaper = ReadFileAndCreateReshaper(onlyfiles[0])
for fileName in onlyfiles:
    if fileName == onlyfiles[0]:
        continue
    AddExtraToShaper(fileName, trainingReshaper)


print("All added now scores")
sys.stdout.flush()

#trainingReshaper.transactionHelper.Print()
a = datetime.datetime.now()
trainingReshaper.finalize()
b = datetime.datetime.now()
elapsedTime = b - a
print("Assigned scores ", elapsedTime.seconds)
sys.stdout.flush()
extraDataManager = extraDataMan.ExtraDataManager(extraFolderPath,transParamList, trainingReshaper.marketState)

